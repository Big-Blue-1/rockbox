# Auto generated documentation by Rockbox plugin API generator v2
# Made by Maurus Cuelenaere
#             __________               __   ___.
#   Open      \______   \ ____   ____ |  | _\_ |__   _______  ___
#   Source     |       _//  _ \_/ ___\|  |/ /| __ \ /  _ \  \/  /
#   Jukebox    |    |   (  <_> )  \___|    < | \_\ (  <_> > <  <
#   Firmware   |____|_  /\____/ \___  >__|_ \|___  /\____/__/\_ \
#                     \/            \/     \/    \/            \/
# $Id$
#
# Generated from http://svn.rockbox.org/viewvc.cgi/trunk/apps/plugin.h
#
# Format:
# \group memory and strings
# \conditions defined(HAVE_BACKLIGHT)
# \param fmt
# \return
# \description
# \see func1 func2 [S[apps/plugin.c]]
#
# Markup:
# [W[wiki url]]
# [S[svn url]]
# [F[function]]
# [[url]]
# %BR%
# =code=

char *strcasestr (const char* phaystack, const char* pneedle)
    \group strings and memory
    \param phaystack
    \param pneedle
    \return
    \description

unsigned char **language_strings
    \return
    \description

int action_get_touchscreen_press(short *x, short *y)
    \group action handling
    \conditions (defined(HAVE_TOUCHSCREEN))
    \param x
    \param y
    \return
    \description

int action_get_touchscreen_press_in_vp(short *x1, short *y1, struct viewport *vp)
    \group action handling
    \conditions (defined(HAVE_TOUCHSCREEN))
    \param x1
    \param y1
    \param vp
    \return
    \description

bool action_userabort(int timeout)
    \group action handling
    \param timeout
    \return
    \description

bool add_event(unsigned short id, void (*handler)(unsigned short id, void *data))
    \group event api
    \param id
    \param handler
    \return
    \description

void add_playbacklog(struct mp3entry *id3)
    \group new stuff at the end, sort into place next time the API gets incompatible
    \param id3
    \description

void adjust_volume(int steps)
    \group sound
    \param steps
    \description

int atoi(const char *str)
    \group strings and memory
    \param str
    \return
    \description

struct mp3entry* audio_current_track(void)
    \group playback control
    \return
    \description

void audio_ff_rewind(long newtime)
    \group playback control
    \param newtime
    \description

void audio_flush_and_reload_tracks(void)
    \group playback control
    \description

int audio_get_file_pos(void)
    \group playback control
    \return
    \description

void audio_hard_stop(void)
    \group playback control
    \conditions (defined(PLUGIN_USE_IRAM))
    \description

void audio_next(void)
    \group playback control
    \description

struct mp3entry* audio_next_track(void)
    \group playback control
    \return
    \description

void audio_pause(void)
    \group playback control
    \description

void audio_play(unsigned long elapsed, unsigned long offset)
    \group playback control
    \param elapsed
    \param offset
    \description

void audio_prev(void)
    \group playback control
    \description

void audio_resume(void)
    \group playback control
    \description

void audio_set_input_source(int source, unsigned flags)
    \group sound
    \conditions (INPUT_SRC_CAPS != 0)
    \param source
    \param flags
    \description

void audio_set_output_source(int monitor)
    \group sound
    \conditions (INPUT_SRC_CAPS != 0)
    \param monitor
    \description

void audio_set_recording_gain(int left, int right, int type)
    \group sound
    \conditions (defined(HAVE_RECORDING))
    \param left
    \param right
    \param type
    \description

int audio_status(void)
    \group playback control
    \return
    \description

void audio_stop(void)
    \group playback control
    \description

void backlight_off(void)
    \group For OLED targets like the Sansa Clip, the backlight_* functions control * the display enable, which has essentially the same effect.
    \conditions (defined(HAVE_BACKLIGHT))
    \description

void backlight_on(void)
    \group For OLED targets like the Sansa Clip, the backlight_* functions control * the display enable, which has essentially the same effect.
    \conditions (defined(HAVE_BACKLIGHT))
    \description

void backlight_set_brightness(int val)
    \group For OLED targets like the Sansa Clip, the backlight_* functions control * the display enable, which has essentially the same effect.
    \conditions (defined(HAVE_BACKLIGHT)) && (defined(HAVE_BACKLIGHT_BRIGHTNESS))
    \param val
    \description

void backlight_set_timeout(int index)
    \group For OLED targets like the Sansa Clip, the backlight_* functions control * the display enable, which has essentially the same effect.
    \conditions (defined(HAVE_BACKLIGHT))
    \param index
    \description

void backlight_set_timeout_plugged(int index)
    \conditions (defined(HAVE_BACKLIGHT)) && (CONFIG_CHARGING)
    \param index
    \description

int battery_current(void)
    \group power
    \return
    \description

int battery_level(void)
    \group power
    \return
    \description

bool battery_level_safe(void)
    \group power
    \return
    \description

int battery_time(void)
    \group power
    \return
    \description

int battery_voltage(void)
    \group power
    \return
    \description

void beep_play(unsigned int frequency, unsigned int duration, unsigned int amplitude)
    \group sound
    \param frequency
    \param duration
    \param amplitude
    \description

unsigned short *bidi_l2v( const unsigned char *str, int orientation )
    \param str
    \param orientation
    \return
    \description

bool browse_id3(struct mp3entry *id3, int playlist_display_index, int playlist_amount, struct tm *modified, int track_ct, int (*view_text)(const char *title, const char *text))
    \param id3
    \param playlist_display_index
    \param playlist_amount
    \param modified
    \param track_ct
    \param view_text
    \return
    \description

int buflib_alloc(struct buflib_context* ctx, size_t size)
    \group the buflib memory management library
    \param ctx
    \param size
    \return
    \description

int buflib_alloc_ex(struct buflib_context* ctx, size_t size, struct buflib_callbacks *ops)
    \group the buflib memory management library
    \param ctx
    \param size
    \param ops
    \return
    \description

int buflib_alloc_maximum(struct buflib_context* ctx, size_t* size, struct buflib_callbacks *ops)
    \group the buflib memory management library
    \param ctx
    \param size
    \param ops
    \return
    \description

size_t buflib_available(struct buflib_context* ctx)
    \group the buflib memory management library
    \param ctx
    \return
    \description

void buflib_buffer_in(struct buflib_context* ctx, int size)
    \group the buflib memory management library
    \param ctx
    \param size
    \description

void* buflib_buffer_out(struct buflib_context* ctx, size_t* size)
    \group the buflib memory management library
    \param ctx
    \param size
    \return
    \description

int buflib_free(struct buflib_context* ctx, int handle)
    \group the buflib memory management library
    \param ctx
    \param handle
    \return
    \description

void* buflib_get_data(struct buflib_context* ctx, int handle)
    \group the buflib memory management library
    \param ctx
    \param handle
    \return
    \description

void buflib_init(struct buflib_context* ctx, void* buf, size_t size)
    \group the buflib memory management library
    \param ctx
    \param buf
    \param size
    \description

bool buflib_shrink(struct buflib_context* ctx, int handle, void* new_start, size_t new_size)
    \group the buflib memory management library
    \param ctx
    \param handle
    \param new_start
    \param new_size
    \return
    \description

void buttonlight_off(void)
    \group button
    \conditions (defined(HAVE_BUTTON_LIGHT))
    \description

void buttonlight_on(void)
    \group button
    \conditions (defined(HAVE_BUTTON_LIGHT))
    \description

void buttonlight_set_brightness(int val)
    \group button
    \conditions (defined(HAVE_BUTTON_LIGHT)) && (defined(HAVE_BUTTONLIGHT_BRIGHTNESS))
    \param val
    \description

void buttonlight_set_timeout(int value)
    \group button
    \conditions (defined(HAVE_BUTTON_LIGHT))
    \param value
    \description

void button_clear_queue(void)
    \group button
    \description

long button_get(bool block)
    \group button
    \param block
    \return
    \description

intptr_t button_get_data(void)
    \group button
    \conditions (defined(HAVE_BUTTON_DATA))
    \return
    \description

bool button_get_sw_poweroff_state(void)
    \group button
    \conditions (defined(HAVE_SW_POWEROFF))
    \return
    \description

long button_get_w_tmo(int ticks)
    \group button
    \param ticks
    \return
    \description

bool button_hold(void)
    \group button
    \conditions (defined(HAS_BUTTON_HOLD))
    \return
    \description

int button_queue_count(void)
    \group button
    \return
    \description

void button_queue_post(long id, intptr_t data)
    \conditions (defined(HAVE_LCD_ENABLE) || defined(HAVE_LCD_SLEEP))
    \param id
    \param data
    \description

void button_set_sw_poweroff_state(bool enable)
    \group button
    \conditions (defined(HAVE_SW_POWEROFF))
    \param enable
    \description

int button_status(void)
    \group button
    \return
    \description

int button_status_wdata(int *pdata)
    \group button
    \conditions (defined(HAVE_BUTTON_DATA))
    \param pdata
    \return
    \description

void cancel_cpu_boost(void)
    \group kernel/ system
    \conditions (defined(HAVE_SCHEDULER_BOOSTCTRL))
    \description

const struct cbmp_bitmap_info_entry *core_bitmaps
    \return
    \description

const unsigned char *font_get_bits( struct font *pf, unsigned short char_code )
    \param pf
    \param char_code
    \return
    \description

const unsigned char* utf8decode(const unsigned char *utf8, unsigned short *ucs)
    \group unicode stuff
    \param utf8
    \param ucs
    \return
    \description

const unsigned char *_rbctype_
    \group strings and memory
    \conditions ((CONFIG_PLATFORM & PLATFORM_NATIVE))
    \return
    \description

bool charger_inserted(void)
    \group power
    \conditions (CONFIG_CHARGING)
    \return
    \description

bool charging_state(void)
    \group power
    \conditions (CONFIG_CHARGING) && (CONFIG_CHARGING >= CHARGING_MONITOR)
    \return
    \description

int close(int fildes)
    \group file
    \param fildes
    \return
    \description

int closedir(DIR *dirp)
    \group dir
    \param dirp
    \return
    \description

int codec_close(void)
    \group misc
    \return
    \description

int codec_load_file(const char* codec, struct codec_api *api)
    \group misc
    \param codec
    \param api
    \return
    \description

int codec_run_proc(void)
    \group misc
    \return
    \description

void codec_thread_do_callback(void (*fn)(void), unsigned int *audio_thread_id)
    \group misc
    \param fn
    \param audio_thread_id
    \description

void commit_dcache(void)
    \description

void commit_discard_dcache(void)
    \description

void commit_discard_idcache(void)
    \description

int core_set_keyremap(struct button_mapping* core_keymap, int count)
    \group action handling
    \param core_keymap
    \param count
    \return
    \description

int count_mp3_frames(int fd, int startpos, int filesize, void (*progressfunc)(int), unsigned char* buf, size_t buflen)
    \group metadata
    \param fd
    \param startpos
    \param filesize
    \param progressfunc
    \param buf
    \param buflen
    \return
    \description

void cpu_boost(bool on_off)
    \group kernel/ system
    \conditions ((CONFIG_PLATFORM & PLATFORM_NATIVE)) && (defined(HAVE_ADJUSTABLE_CPU_FREQ)) && (!( defined(CPU_BOOST_LOGGING) ))
    \param on_off
    \description

void cpu_boost_(bool on_off,char*location,int line)
    \group kernel/ system
    \conditions ((CONFIG_PLATFORM & PLATFORM_NATIVE)) && (defined(HAVE_ADJUSTABLE_CPU_FREQ)) && (defined(CPU_BOOST_LOGGING))
    \param on_off
    \param charlocation
    \param line
    \description

long *cpu_frequency
    \group kernel/ system
    \conditions ((CONFIG_PLATFORM & PLATFORM_NATIVE))
    \return
    \description

uint32_t crc_32(const void *src, uint32_t len, uint32_t crc32)
    \group file
    \param src
    \param len
    \param crc32
    \return
    \description

uint32_t crc_32r(const void *src, uint32_t len, uint32_t crc32)
    \group file
    \param src
    \param len
    \param crc32
    \return
    \description

int creat(const char *path, mode_t mode)
    \group file
    \param path
    \param mode
    \return
    \description

char *create_numbered_filename(char *buffer, const char *path, const char *prefix, const char *suffix, int numberlen IF_CNFN_NUM_(, int *num))
    \group file
    \param buffer
    \param path
    \param prefix
    \param suffix
    \param num
    \param numberlen
    \return
    \description

unsigned int create_thread(void (*function)(void), void* stack, size_t stack_size, unsigned flags, const char *name IF_PRIO(, int priority) IF_COP(, unsigned int core))
    \group kernel/ system
    \param function
    \param stack
    \param stack_size
    \param flags
    \param priority
    \param core
    \param name
    \return
    \description

int create_xing_header(int fd, long startpos, long filesize, unsigned char *buf, unsigned long num_frames, unsigned long rec_time, unsigned long header_template, void (*progressfunc)(int), bool generate_toc, unsigned char* tempbuf, size_t tempbuf_len)
    \group metadata
    \param fd
    \param startpos
    \param filesize
    \param buf
    \param num_frames
    \param rec_time
    \param header_template
    \param progressfunc
    \param generate_toc
    \param tempbuf
    \param tempbuf_len
    \return
    \description

volatile long* current_tick
    \group kernel/ system
    \return
    \description

void debugf(const char *fmt, ...) ATTRIBUTE_PRINTF(1, 2)
    \group misc
    \conditions (defined(DEBUG) || defined(SIMULATOR))
    \param fmt
    \description

long default_event_handler(long event)
    \group kernel/ system
    \param event
    \return
    \description

long default_event_handler_ex(long event, void (*callback)(void *), void *parameter)
    \group kernel/ system
    \param event
    \param callback
    \param parameter
    \return
    \description

bool detect_flashed_ramimage(void)
    \group Routines for the iriver_flash -plugin.
    \conditions (defined(IRIVER_H100_SERIES) || defined(IRIVER_H300_SERIES))
    \return
    \description

bool detect_flashed_romimage(void)
    \group Routines for the iriver_flash -plugin.
    \conditions (defined(IRIVER_H100_SERIES) || defined(IRIVER_H300_SERIES))
    \return
    \description

bool detect_original_firmware(void)
    \group Routines for the iriver_flash -plugin.
    \conditions (defined(IRIVER_H100_SERIES) || defined(IRIVER_H300_SERIES))
    \return
    \description

bool dir_exists(const char *dirname)
    \group dir
    \param dirname
    \return
    \description

struct dirinfo dir_get_info(DIR *dirp, struct dirent *entry)
    \group dir
    \param dirp
    \param entry
    \return
    \description

int do_menu(const struct menu_item_ex *menu, int *start_selected, struct viewport parent[NB_SCREENS], bool hide_theme)
    \group menu
    \param menu
    \param start_selected
    \param parent[NB_SCREENS]
    \param hide_theme
    \return
    \description

intptr_t dsp_configure(struct dsp_config *dsp, unsigned int setting, intptr_t value)
    \group sound
    \param dsp
    \param setting
    \param value
    \return
    \description

void dsp_dither_enable(bool enable)
    \group sound
    \param enable
    \description

void dsp_eq_enable(bool enable)
    \group sound
    \param enable
    \description

struct dsp_config * dsp_get_config(unsigned int dsp_id)
    \group sound
    \param dsp_id
    \return
    \description

int32_t dsp_get_timestretch(void)
    \group sound
    \conditions (defined(HAVE_PITCHCONTROL))
    \return
    \description

void dsp_process(struct dsp_config *dsp, struct dsp_buffer *src, struct dsp_buffer *dst)
    \group sound
    \param dsp
    \param src
    \param dst
    \description

void dsp_set_crossfeed_type(int type)
    \group sound
    \param type
    \description

void dsp_set_timestretch(int32_t percent)
    \group sound
    \conditions (defined(HAVE_PITCHCONTROL))
    \param percent
    \description

bool dsp_timestretch_available(void)
    \group sound
    \conditions (defined(HAVE_PITCHCONTROL))
    \return
    \description

void dsp_timestretch_enable(bool enabled)
    \group sound
    \conditions (defined(HAVE_PITCHCONTROL))
    \param enabled
    \description

int fdprintf(int fildes, const char *fmt, ...) ATTRIBUTE_PRINTF(2, 3)
    \group file
    \param fildes
    \param fmt
    \return
    \description

off_t filesize(int fildes)
    \group file
    \param fildes
    \return
    \description

int filetype_get_attr(const char* file)
    \param file
    \return
    \description

char* filetype_get_plugin(int attr, char *buffer, size_t buffer_len)
    \param attr
    \param buffer
    \param buffer_len
    \return
    \description

bool file_exists(const char *path)
    \group file
    \param path
    \return
    \description

void ** find_array_ptr(void **arr, void *ptr)
    \group misc
    \param arr
    \param ptr
    \return
    \description

void fix_path_part(char* path, int offset, int count)
    \group pathfuncs
    \param path
    \param offset
    \param count
    \description

struct font* font_get(int font)
    \param font
    \return
    \description

int font_getstringsize(const unsigned char *str, int *w, int *h, int fontnumber)
    \param str
    \param w
    \param h
    \param fontnumber
    \return
    \description

int font_get_width(struct font* pf, unsigned short char_code)
    \param pf
    \param char_code
    \return
    \description

int font_load(const char *path)
    \param path
    \return
    \description

void font_unload(int font_id)
    \param font_id
    \description

const char* format_time_auto(char *buffer, int buf_len, long value, int unit_idx, bool supress_unit)
    \group misc
    \param buffer
    \param buf_len
    \param value
    \param unit_idx
    \param supress_unit
    \return
    \description

int ftruncate(int fildes, off_t length)
    \group file
    \param fildes
    \param length
    \return
    \description

int get_action(int context, int timeout)
    \group action handling
    \param context
    \param timeout
    \return
    \description

const char *get_codec_filename(int cod_spec)
    \group misc
    \param cod_spec
    \return
    \description

const char* get_codec_string(int codectype)
    \group metadata
    \param codectype
    \return
    \description

const char* get_codepage_name(int cp)
    \param cp
    \return
    \description

int get_custom_action(int context,int timeout, const struct button_mapping* (*get_context_map)(int))
    \group action handling
    \param context
    \param timeout
    \param get_context_map
    \return
    \description

bool get_metadata(struct mp3entry* id3, int fd, const char* trackname)
    \group metadata
    \param id3
    \param fd
    \param trackname
    \return
    \description

int get_sleep_timer(void)
    \group kernel/ system
    \return
    \description

struct tm* get_time(void)
    \group misc
    \return
    \description

struct user_settings* global_settings
    \return
    \description

struct system_status *global_status
    \return
    \description

struct tm * gmtime_r(const time_t *timep, struct tm *tm)
    \group misc
    \param timep
    \param tm
    \return
    \description

void gui_scrollbar_draw(struct screen * screen, int x, int y, int width, int height, int items, int min_shown, int max_shown, unsigned flags)
    \param screen
    \param x
    \param y
    \param width
    \param height
    \param items
    \param min_shown
    \param max_shown
    \param flags
    \description

void gui_synclist_add_item(struct gui_synclist * lists)
    \group list
    \param lists
    \description

void gui_synclist_del_item(struct gui_synclist * lists)
    \group list
    \param lists
    \description

bool gui_synclist_do_button(struct gui_synclist * lists, int *action)
    \group list
    \param lists
    \param action
    \return
    \description

void gui_synclist_draw(struct gui_synclist * lists)
    \group list
    \param lists
    \description

int gui_synclist_get_nb_items(struct gui_synclist * lists)
    \group list
    \param lists
    \return
    \description

int gui_synclist_get_sel_pos(struct gui_synclist * lists)
    \group list
    \param lists
    \return
    \description

void gui_synclist_init(struct gui_synclist * lists, list_get_name callback_get_item_name, void * data, bool scroll_all,int selected_size, struct viewport parent[NB_SCREENS])
    \group list
    \param lists
    \param callback_get_item_name
    \param data
    \param scroll_all
    \param selected_size
    \param parent[NB_SCREENS]
    \description

void gui_synclist_select_item(struct gui_synclist * lists, int item_number)
    \group list
    \param lists
    \param item_number
    \description

void gui_synclist_set_icon_callback(struct gui_synclist * lists, list_get_icon icon_callback)
    \group list
    \param lists
    \param icon_callback
    \description

void gui_synclist_set_nb_items(struct gui_synclist * lists, int nb_items)
    \group list
    \param lists
    \param nb_items
    \description

void gui_synclist_set_title(struct gui_synclist *lists, const char* title, enum themable_icons icon)
    \group list
    \param lists
    \param title
    \param icon
    \description

void gui_synclist_set_voice_callback(struct gui_synclist * lists, list_speak_item voice_callback)
    \group list
    \param lists
    \param voice_callback
    \description

void gui_synclist_speak_item(struct gui_synclist * lists)
    \group list
    \param lists
    \description

enum yesno_res gui_syncyesno_run(const struct text_message * main_message, const struct text_message * yes_message, const struct text_message * no_message)
    \group list
    \param main_message
    \param yes_message
    \param no_message
    \return
    \description

unsigned char* iso_decode(const unsigned char *iso, unsigned char *utf8, int cp, int count)
    \group unicode stuff
    \param iso
    \param utf8
    \param cp
    \param count
    \return
    \description

bool is_backlight_on(bool ignore_always_off)
    \group For OLED targets like the Sansa Clip, the backlight_* functions control * the display enable, which has essentially the same effect.
    \conditions (defined(HAVE_BACKLIGHT))
    \param ignore_always_off
    \return
    \description

bool is_diacritic(const unsigned short char_code, bool *is_rtl)
    \param char_code
    \param is_rtl
    \return
    \description

int kbd_input(char* buffer, int buflen, unsigned short *kbd)
    \group misc
    \param buffer
    \param buflen
    \param kbd
    \return
    \description

void keyclick_click(bool rawbutton, int action)
    \param rawbutton
    \param action
    \description

int lang_is_rtl(void)
    \group language
    \return
    \description

void lcd_bitmap(const fb_data *src, int x, int y, int width, int height)
    \group lcd
    \conditions (LCD_DEPTH > 1)
    \param src
    \param x
    \param y
    \param width
    \param height
    \description

void lcd_bitmap_part(const fb_data *src, int src_x, int src_y, int stride, int x, int y, int width, int height)
    \group lcd
    \conditions (LCD_DEPTH > 1)
    \param src
    \param src_x
    \param src_y
    \param stride
    \param x
    \param y
    \param width
    \param height
    \description

void lcd_bitmap_transparent(const fb_data *src, int x, int y, int width, int height)
    \group lcd
    \conditions (LCD_DEPTH >= 16)
    \param src
    \param x
    \param y
    \param width
    \param height
    \description

void lcd_bitmap_transparent_part(const fb_data *src, int src_x, int src_y, int stride, int x, int y, int width, int height)
    \group lcd
    \conditions (LCD_DEPTH >= 16)
    \param src
    \param src_x
    \param src_y
    \param stride
    \param x
    \param y
    \param width
    \param height
    \description

void lcd_blit_grey_phase(unsigned char *values, unsigned char *phases, int bx, int by, int bwidth, int bheight, int stride)
    \group lcd
    \conditions ((LCD_DEPTH < 4) && (CONFIG_PLATFORM & PLATFORM_NATIVE))
    \param values
    \param phases
    \param bx
    \param by
    \param bwidth
    \param bheight
    \param stride
    \description

void lcd_blit_mono(const unsigned char *data, int x, int by, int width, int bheight, int stride)
    \group lcd
    \conditions ((LCD_DEPTH < 4) && (CONFIG_PLATFORM & PLATFORM_NATIVE))
    \param data
    \param x
    \param by
    \param width
    \param bheight
    \param stride
    \description

void lcd_blit_pal256(unsigned char *src, int src_x, int src_y, int x, int y, int width, int height)
    \group lcd
    \conditions (defined(HAVE_LCD_MODES) && (HAVE_LCD_MODES & LCD_MODE_PAL256))
    \param src
    \param src_x
    \param src_y
    \param x
    \param y
    \param width
    \param height
    \description

void lcd_blit_yuv(unsigned char * const src[3], int src_x, int src_y, int stride, int x, int y, int width, int height)
    \group lcd
    \conditions (LCD_DEPTH >= 16) && (MEMORYSIZE > 2)
    \param src[3]
    \param src_x
    \param src_y
    \param stride
    \param x
    \param y
    \param width
    \param height
    \description

void lcd_bmp_part(const struct bitmap *bm, int src_x, int src_y, int x, int y, int width, int height)
    \group lcd
    \param bm
    \param src_x
    \param src_y
    \param x
    \param y
    \param width
    \param height
    \description

void lcd_clear_display(void)
    \group lcd
    \description

void lcd_drawline(int x1, int y1, int x2, int y2)
    \group lcd
    \param x1
    \param y1
    \param x2
    \param y2
    \description

void lcd_drawpixel(int x, int y)
    \group lcd
    \param x
    \param y
    \description

void lcd_drawrect(int x, int y, int width, int height)
    \group lcd
    \param x
    \param y
    \param width
    \param height
    \description

void lcd_fillrect(int x, int y, int width, int height)
    \group lcd
    \param x
    \param y
    \param width
    \param height
    \description

int lcd_getstringsize(const unsigned char *str, int *w, int *h)
    \group lcd
    \param str
    \param w
    \param h
    \return
    \description

fb_data* lcd_get_backdrop(void)
    \group lcd
    \conditions (LCD_DEPTH > 1)
    \return
    \description

unsigned lcd_get_background(void)
    \group lcd
    \conditions (LCD_DEPTH > 1)
    \return
    \description

int lcd_get_drawmode(void)
    \group lcd
    \return
    \description

unsigned lcd_get_foreground(void)
    \group lcd
    \conditions (LCD_DEPTH > 1)
    \return
    \description

void lcd_hline(int x1, int x2, int y)
    \group lcd
    \param x1
    \param x2
    \param y
    \description

void lcd_mono_bitmap(const unsigned char *src, int x, int y, int width, int height)
    \group lcd
    \param src
    \param x
    \param y
    \param width
    \param height
    \description

void lcd_mono_bitmap_part(const unsigned char *src, int src_x, int src_y, int stride, int x, int y, int width, int height)
    \group lcd
    \param src
    \param src_x
    \param src_y
    \param stride
    \param x
    \param y
    \param width
    \param height
    \description

void lcd_pal256_update_pal(fb_data *palette)
    \group lcd
    \conditions (defined(HAVE_LCD_MODES) && (HAVE_LCD_MODES & LCD_MODE_PAL256))
    \param palette
    \description

void lcd_puts(int x, int y, const unsigned char *string)
    \group lcd
    \param x
    \param y
    \param string
    \description

void lcd_putsf(int x, int y, const unsigned char *fmt, ...)
    \group lcd
    \param x
    \param y
    \param fmt
    \description

void lcd_putsxy(int x, int y, const unsigned char *string)
    \group lcd
    \param x
    \param y
    \param string
    \description

void lcd_putsxyf(int x, int y, const unsigned char *fmt, ...)
    \group lcd
    \param x
    \param y
    \param fmt
    \description

bool lcd_puts_scroll(int x, int y, const unsigned char* string)
    \group lcd
    \param x
    \param y
    \param string
    \return
    \description

void lcd_remote_bitmap(const fb_remote_data *src, int x, int y, int width, int height)
    \group remote lcd
    \conditions (defined(HAVE_REMOTE_LCD)) && ((LCD_REMOTE_DEPTH > 1))
    \param src
    \param x
    \param y
    \param width
    \param height
    \description

void lcd_remote_bitmap_part(const fb_remote_data *src, int src_x, int src_y, int stride, int x, int y, int width, int height)
    \group remote lcd
    \conditions (defined(HAVE_REMOTE_LCD)) && ((LCD_REMOTE_DEPTH > 1))
    \param src
    \param src_x
    \param src_y
    \param stride
    \param x
    \param y
    \param width
    \param height
    \description

void lcd_remote_clear_display(void)
    \group remote lcd
    \conditions (defined(HAVE_REMOTE_LCD))
    \description

void lcd_remote_drawline(int x1, int y1, int x2, int y2)
    \group remote lcd
    \conditions (defined(HAVE_REMOTE_LCD))
    \param x1
    \param y1
    \param x2
    \param y2
    \description

void lcd_remote_drawpixel(int x, int y)
    \group remote lcd
    \conditions (defined(HAVE_REMOTE_LCD))
    \param x
    \param y
    \description

void lcd_remote_drawrect(int x, int y, int nx, int ny)
    \group remote lcd
    \conditions (defined(HAVE_REMOTE_LCD))
    \param x
    \param y
    \param nx
    \param ny
    \description

void lcd_remote_fillrect(int x, int y, int nx, int ny)
    \group remote lcd
    \conditions (defined(HAVE_REMOTE_LCD))
    \param x
    \param y
    \param nx
    \param ny
    \description

int lcd_remote_getstringsize(const unsigned char *str, int *w, int *h)
    \group remote lcd
    \conditions (defined(HAVE_REMOTE_LCD))
    \param str
    \param w
    \param h
    \return
    \description

unsigned lcd_remote_get_background(void)
    \group remote lcd
    \conditions (defined(HAVE_REMOTE_LCD)) && ((LCD_REMOTE_DEPTH > 1))
    \return
    \description

int lcd_remote_get_drawmode(void)
    \group remote lcd
    \conditions (defined(HAVE_REMOTE_LCD))
    \return
    \description

unsigned lcd_remote_get_foreground(void)
    \group remote lcd
    \conditions (defined(HAVE_REMOTE_LCD)) && ((LCD_REMOTE_DEPTH > 1))
    \return
    \description

void lcd_remote_hline(int x1, int x2, int y)
    \group remote lcd
    \conditions (defined(HAVE_REMOTE_LCD))
    \param x1
    \param x2
    \param y
    \description

void lcd_remote_mono_bitmap(const unsigned char *src, int x, int y, int width, int height)
    \group remote lcd
    \conditions (defined(HAVE_REMOTE_LCD))
    \param src
    \param x
    \param y
    \param width
    \param height
    \description

void lcd_remote_mono_bitmap_part(const unsigned char *src, int src_x, int src_y, int stride, int x, int y, int width, int height)
    \group remote lcd
    \conditions (defined(HAVE_REMOTE_LCD))
    \param src
    \param src_x
    \param src_y
    \param stride
    \param x
    \param y
    \param width
    \param height
    \description

void lcd_remote_puts(int x, int y, const unsigned char *string)
    \group remote lcd
    \conditions (defined(HAVE_REMOTE_LCD))
    \param x
    \param y
    \param string
    \description

void lcd_remote_putsxy(int x, int y, const unsigned char *string)
    \group remote lcd
    \conditions (defined(HAVE_REMOTE_LCD))
    \param x
    \param y
    \param string
    \description

bool lcd_remote_puts_scroll(int x, int y, const unsigned char* string)
    \group remote lcd
    \conditions (defined(HAVE_REMOTE_LCD))
    \param x
    \param y
    \param string
    \return
    \description

void lcd_remote_scroll_stop(void)
    \group remote lcd
    \conditions (defined(HAVE_REMOTE_LCD))
    \description

void lcd_remote_setfont(int font)
    \group remote lcd
    \conditions (defined(HAVE_REMOTE_LCD))
    \param font
    \description

void lcd_remote_set_background(unsigned background)
    \group remote lcd
    \conditions (defined(HAVE_REMOTE_LCD)) && ((LCD_REMOTE_DEPTH > 1))
    \param background
    \description

void lcd_remote_set_contrast(int x)
    \group remote lcd
    \conditions (defined(HAVE_REMOTE_LCD))
    \param x
    \description

void lcd_remote_set_drawmode(int mode)
    \group remote lcd
    \conditions (defined(HAVE_REMOTE_LCD))
    \param mode
    \description

void lcd_remote_set_foreground(unsigned foreground)
    \group remote lcd
    \conditions (defined(HAVE_REMOTE_LCD)) && ((LCD_REMOTE_DEPTH > 1))
    \param foreground
    \description

void lcd_remote_update(void)
    \group remote lcd
    \conditions (defined(HAVE_REMOTE_LCD))
    \description

void lcd_remote_update_rect(int x, int y, int width, int height)
    \group remote lcd
    \conditions (defined(HAVE_REMOTE_LCD))
    \param x
    \param y
    \param width
    \param height
    \description

void lcd_remote_vline(int x, int y1, int y2)
    \group remote lcd
    \conditions (defined(HAVE_REMOTE_LCD))
    \param x
    \param y1
    \param y2
    \description

void lcd_scroll_stop(void)
    \group lcd
    \description

void lcd_setfont(int font)
    \group lcd
    \param font
    \description

void lcd_set_backdrop(fb_data* backdrop)
    \group lcd
    \conditions (LCD_DEPTH > 1)
    \param backdrop
    \description

void lcd_set_background(unsigned foreground)
    \group lcd
    \conditions (LCD_DEPTH > 1)
    \param foreground
    \description

void lcd_set_contrast(int x)
    \group lcd
    \conditions (defined(HAVE_LCD_CONTRAST))
    \param x
    \description

void lcd_set_drawmode(int mode)
    \group lcd
    \param mode
    \description

void lcd_set_foreground(unsigned foreground)
    \group lcd
    \conditions (LCD_DEPTH > 1)
    \param foreground
    \description

void lcd_set_invert_display(bool yesno)
    \group lcd
    \conditions (defined(HAVE_LCD_INVERT))
    \param yesno
    \description

void lcd_set_mode(int mode)
    \group lcd
    \conditions (defined(HAVE_LCD_MODES))
    \param mode
    \description

struct viewport* lcd_set_viewport(struct viewport* vp)
    \group lcd
    \param vp
    \return
    \description

void lcd_update(void)
    \group lcd
    \description

void lcd_update_rect(int x, int y, int width, int height)
    \group lcd
    \param x
    \param y
    \param width
    \param height
    \description

void lcd_vline(int x, int y1, int y2)
    \group lcd
    \param x
    \param y1
    \param y2
    \description

void lcd_yuv_set_options(unsigned options)
    \group lcd
    \conditions (LCD_DEPTH >= 16) && (MEMORYSIZE > 2) && (defined(TOSHIBA_GIGABEAT_F) || defined(SANSA_E200) || defined(SANSA_C200)  || defined(IRIVER_H10) || defined(COWON_D2) || defined(PHILIPS_HDD1630)  || defined(SANSA_FUZE) || defined(SANSA_E200V2) || defined(SANSA_FUZEV2)  || defined(TOSHIBA_GIGABEAT_S) || defined(PHILIPS_SA9200))
    \param options
    \description

void lc_close(void *handle)
    \group load code api for overlay
    \param handle
    \description

void* lc_get_header(void *handle)
    \group load code api for overlay
    \param handle
    \return
    \description

void* lc_open(const char *filename, unsigned char *buf, size_t buf_size)
    \group load code api for overlay
    \param filename
    \param buf
    \param buf_size
    \return
    \description

void* lc_open_from_mem(void* addr, size_t blob_size)
    \group load code api for overlay
    \param addr
    \param blob_size
    \return
    \description

void led(bool on)
    \group misc
    \param on
    \description

void logf(const char *fmt, ...) ATTRIBUTE_PRINTF(1, 2)
    \group misc
    \conditions (defined(ROCKBOX_HAS_LOGF))
    \param fmt
    \description

const unsigned long *audio_master_sampr_list
    \group sound
    \return
    \description

const unsigned long *hw_freq_sampr
    \group sound
    \return
    \description

const unsigned long *rec_freq_sampr
    \group sound
    \conditions (defined(HAVE_RECORDING))
    \return
    \description

off_t lseek(int fildes, off_t offset, int whence)
    \group file
    \param fildes
    \param offset
    \param whence
    \return
    \description

void *memchr(const void *s1, int c, size_t n)
    \group strings and memory
    \param s1
    \param c
    \param n
    \return
    \description

int memcmp(const void *s1, const void *s2, size_t n)
    \group strings and memory
    \param s1
    \param s2
    \param n
    \return
    \description

void* memcpy(void *out, const void *in, size_t n)
    \group strings and memory
    \param out
    \param in
    \param n
    \return
    \description

void* memmove(void *out, const void *in, size_t n)
    \group strings and memory
    \param out
    \param in
    \param n
    \return
    \description

void* memset(void *dst, int c, size_t length)
    \group strings and memory
    \param dst
    \param c
    \param length
    \return
    \description

void mixer_channel_calculate_peaks(enum pcm_mixer_channel channel, struct pcm_peaks *peaks)
    \param channel
    \param peaks
    \description

const void * mixer_channel_get_buffer(enum pcm_mixer_channel channel, int *count)
    \param channel
    \param count
    \return
    \description

size_t mixer_channel_get_bytes_waiting(enum pcm_mixer_channel channel)
    \param channel
    \return
    \description

void mixer_channel_play_data(enum pcm_mixer_channel channel, pcm_play_callback_type get_more, const void *start, size_t size)
    \param channel
    \param get_more
    \param start
    \param size
    \description

void mixer_channel_play_pause(enum pcm_mixer_channel channel, bool play)
    \param channel
    \param play
    \description

void mixer_channel_set_amplitude(enum pcm_mixer_channel channel, unsigned int amplitude)
    \param channel
    \param amplitude
    \description

void mixer_channel_set_buffer_hook(enum pcm_mixer_channel channel, chan_buffer_hook_fn_type fn)
    \param channel
    \param fn
    \description

enum channel_status mixer_channel_status(enum pcm_mixer_channel channel)
    \param channel
    \return
    \description

void mixer_channel_stop(enum pcm_mixer_channel channel)
    \param channel
    \description

unsigned int mixer_get_frequency(void)
    \return
    \description

void mixer_set_frequency(unsigned int samplerate)
    \param samplerate
    \description

int mkdir(const char *path)
    \group dir
    \param path
    \return
    \description

time_t mktime(struct tm *t)
    \group misc
    \conditions (CONFIG_RTC)
    \param t
    \return
    \description

void mutex_init(struct mutex *m)
    \group kernel/ system
    \param m
    \description

void mutex_lock(struct mutex *m)
    \group kernel/ system
    \param m
    \description

void mutex_unlock(struct mutex *m)
    \group kernel/ system
    \param m
    \description

void onplay_show_playlist_cat_menu(const char* track_name, int attr, void (*add_to_pl_cb))
    \param track_name
    \param attr
    \param add_to_pl_cb
    \description

void onplay_show_playlist_menu(const char* path, int attr, void (*playlist_insert_cb))
    \param path
    \param attr
    \param playlist_insert_cb
    \description

int open(const char *path, int oflag, ...)
    \group file
    \param path
    \param oflag
    \return
    \description

DIR * opendir(const char *dirname)
    \group dir
    \param dirname
    \return
    \description

int open_utf8(const char* pathname, int flags)
    \group file
    \param pathname
    \param flags
    \return
    \description

bool option_screen(const struct settings_list *setting, struct viewport parent[NB_SCREENS], bool use_temp_var, const unsigned char* option_title)
    \group options
    \param setting
    \param parent[NB_SCREENS]
    \param use_temp_var
    \param option_title
    \return
    \description

char* output_dyn_value(char *buf, int buf_size, int64_t value, const unsigned char * const *units, unsigned int unit_count, bool binary_scale)
    \group strings and memory
    \param buf
    \param buf_size
    \param value
    \param units
    \param unit_count
    \param binary_scale
    \return
    \description

int path_strip_volume(const char *name, const char **nameptr, bool greedy)
    \group pathfuncs
    \conditions (defined(HAVE_MULTIVOLUME))
    \param name
    \param nameptr
    \param greedy
    \return
    \description

void pcmbuf_fade(bool fade, bool in)
    \param fade
    \param in
    \description

void pcmbuf_set_low_latency(bool state)
    \param state
    \description

void pcm_apply_settings(void)
    \group sound
    \description

void pcm_calculate_rec_peaks(int *left, int *right)
    \group sound
    \conditions (defined(HAVE_RECORDING))
    \param left
    \param right
    \description

void pcm_close_recording(void)
    \group sound
    \conditions (defined(HAVE_RECORDING))
    \description

void pcm_init_recording(void)
    \group sound
    \conditions (defined(HAVE_RECORDING))
    \description

bool pcm_is_playing(void)
    \group sound
    \return
    \description

void pcm_play_data(pcm_play_callback_type get_more, pcm_status_callback_type status_cb, const void *start, size_t size)
    \group sound
    \param get_more
    \param status_cb
    \param start
    \param size
    \description

void pcm_play_lock(void)
    \group sound
    \description

void pcm_play_stop(void)
    \group sound
    \description

void pcm_play_unlock(void)
    \group sound
    \description

void pcm_record_data(pcm_rec_callback_type more_ready, pcm_status_callback_type status_cb, void *start, size_t size)
    \group sound
    \conditions (defined(HAVE_RECORDING))
    \param more_ready
    \param status_cb
    \param start
    \param size
    \description

void pcm_set_frequency(unsigned int frequency)
    \group sound
    \param frequency
    \description

void pcm_stop_recording(void)
    \group sound
    \conditions (defined(HAVE_RECORDING))
    \description

int playlist_amount(void)
    \group playback control
    \return
    \description

int playlist_create(const char *dir, const char *file)
    \group playback control
    \param dir
    \param file
    \return
    \description

bool playlist_entries_iterate(const char *filename, struct playlist_insert_context *pl_context, bool (*action_cb)(const char *file_name))
    \group playback control
    \param filename
    \param pl_context
    \param action_cb
    \return
    \description

struct playlist_info* playlist_get_current(void)
    \group playback control
    \return
    \description

int playlist_get_display_index(void)
    \group playback control
    \return
    \description

int playlist_get_first_index(const struct playlist_info* playlist)
    \group playback control
    \param playlist
    \return
    \description

int playlist_get_resume_info(int *resume_index)
    \group playback control
    \param resume_index
    \return
    \description

int playlist_get_track_info(struct playlist_info* playlist, int index, struct playlist_track_info* info)
    \group playback control
    \param playlist
    \param index
    \param info
    \return
    \description

int playlist_insert_directory(struct playlist_info* playlist, const char *dirname, int position, bool queue, bool recurse)
    \group playback control
    \param playlist
    \param dirname
    \param position
    \param queue
    \param recurse
    \return
    \description

int playlist_insert_playlist(struct playlist_info* playlist, const char *filename, int position, bool queue)
    \group playback control
    \param playlist
    \param filename
    \param position
    \param queue
    \return
    \description

int playlist_insert_track(struct playlist_info* playlist, const char *filename, int position, bool queue, bool sync)
    \group playback control
    \param playlist
    \param filename
    \param position
    \param queue
    \param sync
    \return
    \description

int playlist_remove_all_tracks(struct playlist_info *playlist)
    \group playback control
    \param playlist
    \return
    \description

int playlist_resume(void)
    \group playback control
    \return
    \description

void playlist_resume_track(int start_index, unsigned int crc, unsigned long elapsed, unsigned long offset)
    \group playback control
    \param start_index
    \param crc
    \param elapsed
    \param offset
    \description

void playlist_set_modified(struct playlist_info *playlist, bool modified)
    \group playback control
    \param playlist
    \param modified
    \description

int playlist_shuffle(int random_seed, int start_index)
    \group playback control
    \param random_seed
    \param start_index
    \return
    \description

void playlist_start(int start_index, unsigned long elapsed, unsigned long offset)
    \group playback control
    \param start_index
    \param elapsed
    \param offset
    \description

void playlist_sync(struct playlist_info* playlist)
    \group playback control
    \param playlist
    \description

void* plugin_get_audio_buffer(size_t *buffer_size)
    \group plugin
    \param buffer_size
    \return
    \description

void* plugin_get_buffer(size_t *buffer_size)
    \group plugin
    \param buffer_size
    \return
    \description

char* plugin_get_current_filename(void)
    \group plugin
    \return
    \description

int plugin_open(const char *path, const char *parameter)
    \group plugin
    \param path
    \param parameter
    \return
    \description

void plugin_release_audio_buffer(void)
    \group plugin
    \description

size_t plugin_reserve_buffer(size_t buffer_size)
    \group plugin
    \param buffer_size
    \return
    \description

void plugin_tsr(int (*exit_callback)(bool reenter))
    \group plugin
    \param exit_callback
    \description

void profile_func_enter(void *this_fn, void *call_site)
    \conditions (defined(RB_PROFILE))
    \param this_fn
    \param call_site
    \description

void profile_func_exit(void *this_fn, void *call_site)
    \conditions (defined(RB_PROFILE))
    \param this_fn
    \param call_site
    \description

void profile_thread(void)
    \conditions (defined(RB_PROFILE))
    \description

void profstop(void)
    \conditions (defined(RB_PROFILE))
    \description

void qsort(void *base, size_t nmemb, size_t size, int(*compar)(const void *, const void *))
    \group misc
    \param base
    \param nmemb
    \param size
    \param compar
    \description

void queue_delete(struct event_queue *q)
    \param q
    \description

bool queue_empty(const struct event_queue *q)
    \param q
    \return
    \description

void queue_enable_queue_send(struct event_queue *q, struct queue_sender_list *send, unsigned int thread_id)
    \param q
    \param send
    \param thread_id
    \description

void queue_init(struct event_queue *q, bool register_queue)
    \param q
    \param register_queue
    \description

void queue_post(struct event_queue *q, long id, intptr_t data)
    \param q
    \param id
    \param data
    \description

void queue_remove_from_head(struct event_queue *q, long id)
    \param q
    \param id
    \description

void queue_reply(struct event_queue *q, intptr_t retval)
    \param q
    \param retval
    \description

intptr_t queue_send(struct event_queue *q, long id, intptr_t data)
    \param q
    \param id
    \param data
    \return
    \description

void queue_wait(struct event_queue *q, struct queue_event *ev)
    \param q
    \param ev
    \description

void queue_wait_w_tmo(struct event_queue *q, struct queue_event *ev, int ticks)
    \param q
    \param ev
    \param ticks
    \description

int rand(void)
    \group misc
    \return
    \description

const char *rbversion
    \return
    \description

ssize_t read(int fildes, void *buf, size_t nbyte)
    \group file
    \param fildes
    \param buf
    \param nbyte
    \return
    \description

struct dirent * readdir(DIR *dirp)
    \group dir
    \param dirp
    \return
    \description

int read_bmp_fd(int fd, struct bitmap *bm, int maxsize, int format, const struct custom_format *cformat)
    \param fd
    \param bm
    \param maxsize
    \param format
    \param cformat
    \return
    \description

int read_bmp_file(const char* filename, struct bitmap *bm, int maxsize, int format, const struct custom_format *cformat)
    \param filename
    \param bm
    \param maxsize
    \param format
    \param cformat
    \return
    \description

int read_jpeg_fd(int fd, struct bitmap *bm, int maxsize, int format, const struct custom_format *cformat)
    \conditions (defined(HAVE_JPEG))
    \param fd
    \param bm
    \param maxsize
    \param format
    \param cformat
    \return
    \description

int read_jpeg_file(const char* filename, struct bitmap *bm, int maxsize, int format, const struct custom_format *cformat)
    \conditions (defined(HAVE_JPEG))
    \param filename
    \param bm
    \param maxsize
    \param format
    \param cformat
    \return
    \description

int read_line(int fd, char* buffer, int buffer_size)
    \group file
    \param fd
    \param buffer
    \param buffer_size
    \return
    \description

void register_storage_idle_func(void (*function)(void))
    \group file
    \conditions (USING_STORAGE_CALLBACK)
    \param function
    \description

void reload_directory(void)
    \group file
    \description

void remote_backlight_off(void)
    \conditions (defined(HAVE_BACKLIGHT)) && (defined(HAVE_REMOTE_LCD))
    \description

void remote_backlight_on(void)
    \conditions (defined(HAVE_BACKLIGHT)) && (defined(HAVE_REMOTE_LCD))
    \description

void remote_backlight_set_timeout(int index)
    \conditions (defined(HAVE_BACKLIGHT)) && (defined(HAVE_REMOTE_LCD))
    \param index
    \description

void remote_backlight_set_timeout_plugged(int index)
    \conditions (defined(HAVE_BACKLIGHT)) && (defined(HAVE_REMOTE_LCD)) && (CONFIG_CHARGING)
    \param index
    \description

int remove(const char *path)
    \group file
    \param path
    \return
    \description

int remove_array_ptr(void **arr, void *ptr)
    \group misc
    \param arr
    \param ptr
    \return
    \description

void remove_event(unsigned short id, void (*handler)(unsigned short id, void *data))
    \group event api
    \param id
    \param handler
    \description

int rename(const char *old, const char *new)
    \group file
    \param old
    \param new
    \return
    \description

void reset_poweroff_timer(void)
    \group kernel/ system
    \description

int rmdir(const char *path)
    \group dir
    \param path
    \return
    \description

int rockbox_browse(struct browse_context *browse)
    \group browsing
    \param browse
    \return
    \description

struct menu_table *root_menu_get_options(int *nb_options)
    \group menu
    \param nb_options
    \return
    \description

void root_menu_load_from_cfg(void* setting, char *value)
    \group menu
    \param setting
    \param value
    \description

void root_menu_set_default(void* setting, void* defaultval)
    \group menu
    \param setting
    \param defaultval
    \description

char* root_menu_write_to_cfg(void* setting, char*buf, int buf_len)
    \group menu
    \param setting
    \param charbuf
    \param buf_len
    \return
    \description

int round_value_to_list32(unsigned long value, const unsigned long list[], int count, bool signd)
    \group misc
    \param value
    \param list[]
    \param count
    \param signd
    \return
    \description

struct screen* screens[NB_SCREENS]
    \group remote lcd
    \return
    \description

void screen_clear_area(struct screen * display, int xstart, int ystart, int width, int height)
    \param display
    \param xstart
    \param ystart
    \param width
    \param height
    \description

void screen_dump_set_hook(void (*hook)(int fh))
    \param hook
    \description

bool search_albumart_files(const struct mp3entry *id3, const char *size_string, char *buf, int buflen)
    \conditions (defined(HAVE_ALBUMART))
    \param id3
    \param size_string
    \param buf
    \param buflen
    \return
    \description

void semaphore_init(struct semaphore *s, int max, int start)
    \group kernel/ system
    \conditions (defined(HAVE_SEMAPHORE_OBJECTS))
    \param s
    \param max
    \param start
    \description

void semaphore_release(struct semaphore *s)
    \group kernel/ system
    \conditions (defined(HAVE_SEMAPHORE_OBJECTS))
    \param s
    \description

int semaphore_wait(struct semaphore *s, int timeout)
    \group kernel/ system
    \conditions (defined(HAVE_SEMAPHORE_OBJECTS))
    \param s
    \param timeout
    \return
    \description

void send_event(unsigned short id, void *data)
    \group event api
    \param id
    \param data
    \description

const struct settings_list* find_setting(const void* variable)
    \group options
    \param variable
    \return
    \description

const struct settings_list* get_settings_list(int*count)
    \group options
    \param intcount
    \return
    \description

bool settings_parseline(char* line, char** name, char** value)
    \group file
    \param line
    \param name
    \param value
    \return
    \description

int settings_save(void)
    \group options
    \return
    \description

bool set_bool(const char* string, const bool* variable )
    \group options
    \param string
    \param variable
    \return
    \description

bool set_bool_options(const char* string, const bool* variable, const char* yes_str, int yes_voice, const char* no_str, int no_voice, void (*function)(bool))
    \group options
    \param string
    \param variable
    \param yes_str
    \param yes_voice
    \param no_str
    \param no_voice
    \param function
    \return
    \description

bool set_color(struct screen *display, char *title, unsigned *color, unsigned banned_color)
    \conditions (defined(HAVE_LCD_COLOR))
    \param display
    \param title
    \param color
    \param banned_color
    \return
    \description

void set_current_file(const char* path)
    \param path
    \description

void set_dirfilter(int l_dirfilter)
    \param l_dirfilter
    \description

bool set_int(const unsigned char* string, const char* unit, int voice_unit, const int* variable, void (*function)(int), int step, int min, int max, const char* (*formatter)(char*, size_t, int, const char*) )
    \group options
    \param string
    \param unit
    \param voice_unit
    \param variable
    \param function
    \param step
    \param min
    \param max
    \param formatter
    \return
    \description

bool set_int_ex(const unsigned char* string, const char* unit, int voice_unit, const int* variable, void (*function)(int), int step, int min, int max, const char* (*formatter)(char*, size_t, int, const char*) , int32_t (*get_talk_id)(int, int))
    \group options
    \param string
    \param unit
    \param voice_unit
    \param variable
    \param function
    \param step
    \param min
    \param max
    \param formatter
    \param get_talk_id
    \return
    \description

bool set_option(const char* string, const void* variable, enum optiontype type, const struct opt_items* options, int numoptions, void (*function)(int))
    \group options
    \param string
    \param variable
    \param type
    \param options
    \param numoptions
    \param function
    \return
    \description

void set_sleeptimer_duration(int minutes)
    \group kernel/ system
    \param minutes
    \description

void simplelist_info_init(struct simplelist_info *info, char* title, int count, void* data)
    \group list
    \param info
    \param title
    \param count
    \param data
    \description

bool simplelist_show_list(struct simplelist_info *info)
    \group list
    \param info
    \return
    \description

void sim_lcd_ex_init(unsigned long (*getpixel)(int, int))
    \group special simulator hooks
    \conditions ((CONFIG_PLATFORM & PLATFORM_HOSTED)) && (LCD_DEPTH < 8)
    \param getpixel
    \description

void sim_lcd_ex_update_rect(int x, int y, int width, int height)
    \group special simulator hooks
    \conditions ((CONFIG_PLATFORM & PLATFORM_HOSTED)) && (LCD_DEPTH < 8)
    \param x
    \param y
    \param width
    \param height
    \description

int snprintf(char *buf, size_t size, const char *fmt, ...) ATTRIBUTE_PRINTF(3, 4)
    \group strings and memory
    \param buf
    \param size
    \param fmt
    \return
    \description

int sound_current(int setting); /*stub*
    \group sound
    \param setting
    \return
    \description

int sound_default(int setting)
    \group sound
    \param setting
    \return
    \description

int sound_enum_hw_eq_band_setting(unsigned int band, unsigned int band_setting)
    \group sound
    \conditions (defined(AUDIOHW_HAVE_EQ))
    \param band
    \param band_setting
    \return
    \description

int32_t sound_get_pitch(void)
    \group sound
    \conditions (defined (HAVE_PITCHCONTROL))
    \return
    \description

int sound_max(int setting)
    \group sound
    \param setting
    \return
    \description

int sound_min(int setting)
    \group sound
    \param setting
    \return
    \description

void sound_set(int setting, int value)
    \group sound
    \param setting
    \param value
    \description

void sound_set_pitch(int32_t pitch)
    \group sound
    \conditions (defined (HAVE_PITCHCONTROL))
    \param pitch
    \description

const char * sound_unit(int setting)
    \group sound
    \param setting
    \return
    \description

int sound_val2phys(int setting, int value)
    \group sound
    \param setting
    \param value
    \return
    \description

void splash(int ticks, const char *str)
    \group lcd
    \param ticks
    \param str
    \description

void splashf(int ticks, const char *fmt, ...) ATTRIBUTE_PRINTF(2, 3)
    \group lcd
    \param ticks
    \param fmt
    \description

void splash_progress(int current, int total, const char *fmt, ...) ATTRIBUTE_PRINTF(3, 4)
    \group lcd
    \param current
    \param total
    \param fmt
    \description

void splash_progress_set_delay(long delay_ticks)
    \group lcd
    \param delay_ticks
    \description

void srand(unsigned int seed)
    \group misc
    \param seed
    \description

void storage_sleep(void)
    \group file
    \description

void storage_spin(void)
    \group file
    \description

void storage_spindown(int seconds)
    \group file
    \param seconds
    \description

int strcasecmp(const char *, const char *)
    \group strings and memory
    \param 
    \param 
    \return
    \description

char *strcat(char *s1, const char *s2)
    \group strings and memory
    \param s1
    \param s2
    \return
    \description

char *strchr(const char *s, int c)
    \group strings and memory
    \param s
    \param c
    \return
    \description

int strcmp(const char *, const char *)
    \group strings and memory
    \param 
    \param 
    \return
    \description

char* strcpy(char *dst, const char *src)
    \group strings and memory
    \param dst
    \param src
    \return
    \description

char* strip_extension(char* buffer, int buffer_size, const char *filename)
    \group file
    \param buffer
    \param buffer_size
    \param filename
    \return
    \description

size_t strlcat(char *dst, const char *src, size_t length)
    \group strings and memory
    \param dst
    \param src
    \param length
    \return
    \description

size_t strlcpy(char *dst, const char *src, size_t length)
    \group strings and memory
    \param dst
    \param src
    \param length
    \return
    \description

size_t strlen(const char *str)
    \group strings and memory
    \param str
    \return
    \description

int strncasecmp(const char *s1, const char *s2, size_t n)
    \group strings and memory
    \param s1
    \param s2
    \param n
    \return
    \description

int strncmp(const char *, const char *, size_t)
    \group strings and memory
    \param 
    \param 
    \param size_t
    \return
    \description

char * strrchr(const char *s, int c)
    \group strings and memory
    \param s
    \param c
    \return
    \description

char* strtok_r(char *ptr, const char *sep, char **end)
    \group strings and memory
    \param ptr
    \param sep
    \param end
    \return
    \description

int system_memory_guard(int newmode)
    \group kernel/ system
    \conditions ((CONFIG_PLATFORM & PLATFORM_NATIVE))
    \param newmode
    \return
    \description

void system_sound_play(enum system_sound sound)
    \param sound
    \description

void sys_poweroff(void)
    \group reboot and poweroff
    \description

void sys_reboot(void)
    \group reboot and poweroff
    \description

void tagcache_commit_finalize(void)
    \group metadata
    \conditions (defined(HAVE_TAGCACHE))
    \description

bool tagcache_fill_tags(struct mp3entry *id3, const char *filename)
    \group metadata
    \conditions (defined(HAVE_TAGCACHE)) && (defined(HAVE_TC_RAMCACHE)) && (defined(HAVE_DIRCACHE))
    \param id3
    \param filename
    \return
    \description

bool tagcache_get_next(struct tagcache_search *tcs, char *buf, long size)
    \group metadata
    \conditions (defined(HAVE_TAGCACHE))
    \param tcs
    \param buf
    \param size
    \return
    \description

long tagcache_get_numeric(const struct tagcache_search *tcs, int tag)
    \group metadata
    \conditions (defined(HAVE_TAGCACHE))
    \param tcs
    \param tag
    \return
    \description

struct tagcache_stat* tagcache_get_stat(void)
    \group metadata
    \conditions (defined(HAVE_TAGCACHE))
    \return
    \description

bool tagcache_is_in_ram(void)
    \group metadata
    \conditions (defined(HAVE_TAGCACHE)) && (defined(HAVE_TC_RAMCACHE))
    \return
    \description

bool tagcache_retrieve(struct tagcache_search *tcs, int idxid, int tag, char *buf, long size)
    \group metadata
    \conditions (defined(HAVE_TAGCACHE))
    \param tcs
    \param idxid
    \param tag
    \param buf
    \param size
    \return
    \description

bool tagcache_search(struct tagcache_search *tcs, int tag)
    \group metadata
    \conditions (defined(HAVE_TAGCACHE))
    \param tcs
    \param tag
    \return
    \description

bool tagcache_search_add_filter(struct tagcache_search *tcs, int tag, int seek)
    \group metadata
    \conditions (defined(HAVE_TAGCACHE))
    \param tcs
    \param tag
    \param seek
    \return
    \description

void tagcache_search_finish(struct tagcache_search *tcs)
    \group metadata
    \conditions (defined(HAVE_TAGCACHE))
    \param tcs
    \description

void tagcache_search_set_uniqbuf(struct tagcache_search *tcs, void *buffer, long length)
    \group metadata
    \conditions (defined(HAVE_TAGCACHE))
    \param tcs
    \param buffer
    \param length
    \description

bool tagtree_subentries_do_action(bool (*action_cb)(const char *file_name))
    \group metadata
    \conditions (defined(HAVE_TAGCACHE))
    \param action_cb
    \return
    \description

void talk_date(const struct tm *tm, bool enqueue)
    \group talking
    \param tm
    \param enqueue
    \description

int talk_dir_or_spell(const char* filename, const long *prefix_ids, bool enqueue)
    \group talking
    \param filename
    \param prefix_ids
    \param enqueue
    \return
    \description

void talk_disable(bool disable)
    \group talking
    \param disable
    \description

int talk_file(const char *root, const char *dir, const char *file, const char *ext, const long *prefix_ids, bool enqueue)
    \group talking
    \param root
    \param dir
    \param file
    \param ext
    \param prefix_ids
    \param enqueue
    \return
    \description

int talk_file_or_spell(const char *dirname, const char* filename, const long *prefix_ids, bool enqueue)
    \group talking
    \param dirname
    \param filename
    \param prefix_ids
    \param enqueue
    \return
    \description

void talk_force_enqueue_next(void)
    \group talking
    \description

void talk_force_shutup(void)
    \group talking
    \description

int talk_fullpath(const char* path, bool enqueue)
    \group talking
    \param path
    \param enqueue
    \return
    \description

int talk_id(int32_t id, bool enqueue)
    \group talking
    \param id
    \param enqueue
    \return
    \description

int talk_idarray(const long *idarray, bool enqueue)
    \group talking
    \param idarray
    \param enqueue
    \return
    \description

int talk_number(long n, bool enqueue)
    \group talking
    \param n
    \param enqueue
    \return
    \description

void talk_shutup(void)
    \group talking
    \description

int talk_spell(const char* spell, bool enqueue)
    \group talking
    \param spell
    \param enqueue
    \return
    \description

void talk_time(const struct tm *tm, bool enqueue)
    \group talking
    \param tm
    \param enqueue
    \description

int talk_value_decimal(long n, int unit, int decimals, bool enqueue)
    \group talking
    \param n
    \param unit
    \param decimals
    \param enqueue
    \return
    \description

void thread_exit(void)
    \group kernel/ system
    \description

unsigned int thread_self(void)
    \group kernel/ system
    \return
    \description

int thread_set_priority(unsigned int thread_id, int priority)
    \group kernel/ system
    \conditions (defined(HAVE_PRIORITY_SCHEDULING))
    \param thread_id
    \param priority
    \return
    \description

void thread_thaw(unsigned int thread_id)
    \group kernel/ system
    \param thread_id
    \description

void thread_wait(unsigned int thread_id)
    \group kernel/ system
    \param thread_id
    \description

unsigned sleep(unsigned ticks)
    \group kernel/ system
    \param ticks
    \return
    \description

bool timer_register(int reg_prio, void (*unregister_callback)(void), long cycles, void (*timer_callback)(void) IF_COP(, int core))
    \param reg_prio
    \param unregister_callback
    \param cycles
    \param core
    \param timer_callback
    \return
    \description

bool timer_set_period(long count)
    \param count
    \return
    \description

void timer_unregister(void)
    \description

enum touchscreen_mode touchscreen_get_mode(void)
    \group button
    \conditions (defined(HAVE_TOUCHSCREEN))
    \return
    \description

void touchscreen_set_mode(enum touchscreen_mode)
    \group button
    \conditions (defined(HAVE_TOUCHSCREEN))
    \param touchscreen_mode
    \description

struct tree_context* tree_get_context(void)
    \group browsing
    \return
    \description

struct entry* tree_get_entries(struct tree_context* t)
    \group browsing
    \param t
    \return
    \description

struct entry* tree_get_entry_at(struct tree_context* t, int index)
    \group browsing
    \param t
    \param index
    \return
    \description

void trigger_cpu_boost(void)
    \group kernel/ system
    \conditions (defined(HAVE_SCHEDULER_BOOSTCTRL))
    \description

void unregister_storage_idle_func(void (*function)(void), bool run)
    \group file
    \conditions (USING_STORAGE_CALLBACK)
    \param function
    \param run
    \description

void usb_acknowledge(long id)
    \group usb
    \param id
    \description

void usb_hid_send(usage_page_t usage_page, int id)
    \group usb
    \conditions (defined(USB_ENABLE_HID))
    \param usage_page
    \param id
    \description

bool usb_inserted(void)
    \group usb
    \return
    \description

unsigned char* utf8encode(unsigned long ucs, unsigned char *utf8)
    \group unicode stuff
    \param ucs
    \param utf8
    \return
    \description

unsigned long utf8length(const unsigned char *utf8)
    \group unicode stuff
    \param utf8
    \return
    \description

int utf8seek(const unsigned char* utf8, int offset)
    \group unicode stuff
    \param utf8
    \param offset
    \return
    \description

unsigned char* utf16BEdecode(const unsigned char *utf16, unsigned char *utf8, int count)
    \group unicode stuff
    \param utf16
    \param utf8
    \param count
    \return
    \description

unsigned char* utf16LEdecode(const unsigned char *utf16, unsigned char *utf8, int count)
    \group unicode stuff
    \param utf16
    \param utf8
    \param count
    \return
    \description

void viewportmanager_theme_enable(enum screen_type screen, bool enable, struct viewport *viewport)
    \param screen
    \param enable
    \param viewport
    \description

void viewportmanager_theme_undo(enum screen_type screen, bool force_redraw)
    \param screen
    \param force_redraw
    \description

void viewport_set_buffer(struct viewport *vp, struct frame_buffer_t *buffer, const enum screen_type screen)
    \param vp
    \param buffer
    \param screen
    \description

void viewport_set_defaults(struct viewport *vp, const enum screen_type screen)
    \param vp
    \param screen
    \description

void viewport_set_fullscreen(struct viewport *vp, const enum screen_type screen)
    \param vp
    \param screen
    \description

int vsnprintf(char *buf, size_t size, const char *fmt, va_list ap)
    \group strings and memory
    \param buf
    \param size
    \param fmt
    \param ap
    \return
    \description

int vuprintf(vuprintf_push_cb push, void *userp, const char *fmt, va_list ap)
    \group strings and memory
    \param push
    \param userp
    \param fmt
    \param ap
    \return
    \description

bool warn_on_pl_erase(void)
    \group playback control
    \return
    \description

void wheel_send_events(bool send)
    \conditions (defined(HAVE_WHEEL_POSITION))
    \param send
    \description

int wheel_status(void)
    \conditions (defined(HAVE_WHEEL_POSITION))
    \return
    \description

ssize_t write(int fildes, const void *buf, size_t nbyte)
    \group file
    \param fildes
    \param buf
    \param nbyte
    \return
    \description

bool yesno_pop(const char* text)
    \group list
    \param text
    \return
    \description

void yield(void)
    \group kernel/ system
    \description

void __div0(void)
    \group kernel/ system
    \conditions (defined(ARM_NEED_DIV0))
    \description

int * __errno(void)
    \group misc
    \conditions ((CONFIG_PLATFORM & PLATFORM_NATIVE))
    \return
    \description

# END
